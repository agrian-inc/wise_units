//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated at compile time.
//-----------------------------------------------------------------------------

// Because long numbers are generated, there's no way (that I know of) to
// generate them using underscores (to make them pass the clippy lint).
#![cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]

use classification::Classification;
use composable::Composable;
use composition::Composition;
use definition::Definition;
use dimension::Dimension;
use function_set::FunctionSet;
use property::Property;
use std::fmt;
use ucum_symbol::UcumSymbol;

// TODO: Implement PartialEq
#[cfg_attr(feature = "with_serde", derive(Serialize, Deserialize))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Atom {
    {{~ #each atoms }}
    {{ type_name }},{{ /each }}
}

impl UcumSymbol for Atom {
    fn classification(&self) -> Classification {
        match *self {
            {{~ #each atoms }}
            Atom::{{ type_name }} => Classification::{{ classification }},{{ /each }}
        }
    }

    fn definition(&self) -> Definition {
        let result = match *self {
            {{~ #each atoms }}
            Atom::{{ type_name }} => Definition::new({{ definition_signature }}),{{ /each }}
        };

        result.expect("BUG! Bad Atom -> Definition mapping!")
    }

    fn is_arbitrary(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_arbitrary }}
            Atom::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }

    fn is_special(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_special }}
            Atom::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }

    fn is_metric(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_metric }}
            Atom::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }

    fn names(&self) -> Vec<&'static str> {
        match *self {
            {{~ #each atoms }}
            Atom::{{ type_name }} => vec![{{ #each names }}"{{ this }}",{{ /each}}],{{ /each }}
        }
    }

    fn primary_code(&self) -> &'static str {
        match *self {
            {{~ #each atoms }}
            Atom::{{ type_name }} => "{{ primary_code }}",{{ /each }}
        }
    }

    fn print_symbol(&self) -> Option<&'static str> {
        match *self {
            {{~ #each atoms }}
            {{~ #if print_symbol }}
            Atom::{{ type_name }} => Some("{{ print_symbol }}"),
            {{~ /if}}{{ /each }}
            _ => None,
        }
    }

    fn property(&self) -> Property {
        match *self {
            {{~ #each atoms }}
            Atom::{{ type_name }} => Property::{{ camelCase property }},{{ /each }}
        }
    }

    fn secondary_code(&self) -> Option<&'static str> {
        match *self {
            {{~ #each atoms }}
            {{~ #if secondary_code }}
            Atom::{{ type_name }} => Some("{{ secondary_code }}"),
            {{~ /if ~}}{{ /each }}
            _ => None,
        }
    }

    fn scalar(&self) -> f64 {
        debug!("scalar()");

        self.calculate_scalar(1.0)
    }

    fn magnitude(&self) -> f64 {
        debug!("magnitude()");

        self.calculate_magnitude(self.scalar())
    }

    fn calculate_scalar(&self, value: f64) -> f64 {
        debug!("calculate_scalar()");

        self.definition().calculate_scalar(value)
    }

    fn calculate_magnitude(&self, value: f64) -> f64 {
        debug!("calculate_magnitude()");

        if self.is_special() {
            self.definition().calculate_magnitude(value)
        } else {
            1.0
        }
    }
}

impl Composable for Atom {
    fn composition(&self) -> Composition {
        match *self {
            Atom::Candela => Composition::new(Dimension::LuminousIntensity, 1),
            Atom::Coulomb => Composition::new(Dimension::ElectricCharge, 1),
            Atom::Gram => Composition::new(Dimension::Mass, 1),
            Atom::Kelvin => Composition::new(Dimension::Temperature, 1),
            Atom::Meter => Composition::new(Dimension::Length, 1),
            Atom::Radian => Composition::new(Dimension::PlaneAngle, 1),
            Atom::Second => Composition::new(Dimension::Time, 1),
            _ => self.definition().terms.composition(),
        }
    }
}

impl fmt::Display for Atom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.primary_code())
    }
}
