//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated at compile time.
//-----------------------------------------------------------------------------

// Because long numbers are generated, there's no way (that I know of) to
// generate them using underscores (to make them pass the clippy lint).
#[cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]
pub mod atom {
    use num_rational::BigRational;
    use parser::{Classification, Composable, Composition, definition::Definition, Dimension, function_set::FunctionSet, Property, UcumSymbol};
    use num_help::{BigRationalPow, BigRationalSqrt, BR_1, BR_E, NaturalLog, Log2, Log10, Trigonometry};
    use reducible::Reducible;
    use std::fmt;
    use unit::Unit;
    use ucum_unit::UcumUnit;

    lazy_static! { static ref BR_50000: BigRational = big_rational_raw!(50_000, 1); }
    lazy_static! { static ref BR_1000: BigRational = big_rational_raw!(1000, 1); }
    lazy_static! { static ref BR_100: BigRational = big_rational_raw!(100, 1); }
    lazy_static! { static ref BR_10: BigRational = big_rational_raw!(10, 1); }
    lazy_static! { static ref BR_2: BigRational = big_rational_raw!(2, 1); }

    lazy_static! { static ref BR_459_67: BigRational = BigRational::from_float(459.67).unwrap(); }
    lazy_static! { static ref BR_273_15: BigRational = BigRational::from_float(273.15).unwrap(); }
    lazy_static! { static ref BR_0_8: BigRational = BigRational::from_float(0.8).unwrap(); }

    #[cfg_attr(feature = "with_serde", derive(Serialize, Deserialize))]
    #[derive(Clone, Copy, Debug, Eq)]
    pub enum Atom {
        {{~ #each atoms }}
        {{ type_name }},{{ /each }}
    }

    impl Atom {
        pub(crate) fn definition(self) -> Definition {
            let result = match self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => {{ definition_signature }},{{ /each }}
            };

            result.expect("BUG! Bad Atom -> Definition mapping!")
        }

        pub fn property(self) -> Property {
            match self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => Property::{{ camelCase property }},{{ /each }}
            }
        }
    }

    impl UcumSymbol for Atom {
        fn classification(&self) -> Classification {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => Classification::{{ classification }},{{ /each }}
            }
        }

        fn names(&self) -> Vec<&'static str> {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => vec![{{ #each names }}"{{ this }}",{{ /each}}],{{ /each }}
            }
        }

        fn primary_code(&self) -> &'static str {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => "{{ primary_code }}",{{ /each }}
            }
        }

        fn print_symbol(&self) -> Option<&'static str> {
            match *self {
                {{~ #each atoms }}
                {{~ #if print_symbol }}
                Atom::{{ type_name }} => Some("{{ print_symbol }}"),
                {{~ /if}}{{ /each }}
                _ => None,
            }
        }

        fn secondary_code(&self) -> Option<&'static str> {
            match *self {
                {{~ #each atoms }}
                {{~ #if secondary_code }}
                Atom::{{ type_name }} => Some("{{ secondary_code }}"),
                {{~ /if ~}}{{ /each }}
                _ => None,
            }
        }

        fn definition_value(&self) -> BigRational {
            self.definition().value().clone()
        }

        fn definition_unit(&self) -> Unit {
            self.definition().terms().to_vec().into()
        }
    }

    impl UcumUnit for Atom {
        fn scalar(&self) -> BigRational {
            self.reduce_value(&*BR_1)
        }

        fn magnitude(&self) -> BigRational {
            self.calculate_magnitude(&self.scalar())
        }

        fn is_arbitrary(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_arbitrary }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }

        fn is_special(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_special }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }

        fn is_metric(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_metric }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }
    }

    impl<'a> Reducible<&'a BigRational> for Atom {
        fn reduce_value(&self, value: &'a BigRational) -> BigRational {
            self.definition().reduce_value(&value)
        }

        fn calculate_magnitude(&self, value: &'a BigRational) -> BigRational {
            if self.is_special() {
                self.definition().calculate_magnitude(&value)
            } else {
                BR_1.clone()
            }
        }
    }

    impl Composable for Atom {
        fn composition(&self) -> Composition {
            match *self {
                Atom::Candela => Composition::new(Dimension::LuminousIntensity, 1),
                Atom::Coulomb => Composition::new(Dimension::ElectricCharge, 1),
                Atom::Gram => Composition::new(Dimension::Mass, 1),
                Atom::Kelvin => Composition::new(Dimension::Temperature, 1),
                Atom::Meter => Composition::new(Dimension::Length, 1),
                Atom::Radian => Composition::new(Dimension::PlaneAngle, 1),
                Atom::Second => Composition::new(Dimension::Time, 1),
                _ => self.definition().terms().composition(),
            }
        }
    }

    impl PartialEq for Atom {
        fn eq(&self, other: &Self) -> bool {
            if !self.is_compatible_with(other) {
                return false;
            }

            self.scalar() == other.scalar()
        }
    }

    impl fmt::Display for Atom {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", self.primary_code())
        }
    }
}
