//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated at compile time.
//-----------------------------------------------------------------------------

// Because long numbers are generated, there's no way (that I know of) to
// generate them using underscores (to make them pass the clippy lint).
#[cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]
pub mod atom {
    use crate::is_compatible_with::{DefaultCompatibility, IsCompatibleWith};
    use crate::parser::{
        Classification, Composable, Composition, definition::Definition,
        Dimension, function_set::FunctionSet, Property, UcumSymbol,
    };
    use crate::reducible::Reducible;
    use crate::unit::Unit;
    use crate::ucum_unit::UcumUnit;
    use std::fmt;

    #[cfg_attr(feature = "with_serde", derive(Serialize, Deserialize))]
    #[derive(Clone, Copy, Debug, Eq, PartialOrd, Ord)]
    pub enum Atom {
        {{~ #each atoms }}
        {{ type_name }},{{ /each }}
    }

    impl Atom {
        pub(crate) fn definition(self) -> Definition {
            let result = match self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => {{ definition_signature }},{{ /each }}
            };

            result.expect("BUG! Bad Atom -> Definition mapping!")
        }

        pub fn property(self) -> Property {
            match self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => Property::{{ camelCase property }},{{ /each }}
            }
        }
    }

    impl UcumSymbol for Atom {
        fn classification(&self) -> Classification {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => Classification::{{ classification }},{{ /each }}
            }
        }

        fn names(&self) -> Vec<&'static str> {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => vec![{{ #each names }}"{{ this }}",{{ /each}}],{{ /each }}
            }
        }

        fn primary_code(&self) -> &'static str {
            match *self {
                {{~ #each atoms }}
                Atom::{{ type_name }} => "{{ primary_code }}",{{ /each }}
            }
        }

        fn print_symbol(&self) -> Option<&'static str> {
            match *self {
                {{~ #each atoms }}
                {{~ #if print_symbol }}
                Atom::{{ type_name }} => Some("{{ print_symbol }}"),
                {{~ /if}}{{ /each }}
                _ => None,
            }
        }

        fn secondary_code(&self) -> Option<&'static str> {
            match *self {
                {{~ #each atoms }}
                {{~ #if secondary_code }}
                Atom::{{ type_name }} => Some("{{ secondary_code }}"),
                {{~ /if ~}}{{ /each }}
                _ => None,
            }
        }

        fn definition_value(&self) -> f64 {
            self.definition().value()
        }

        fn definition_unit(&self) -> Unit {
            self.definition().terms().to_vec().into()
        }
    }

    impl UcumUnit for Atom {
        fn scalar(&self) -> f64 {
            self.reduce_value(1.0)
        }

        fn magnitude(&self) -> f64 {
            self.calculate_magnitude(self.scalar())
        }

        fn is_arbitrary(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_arbitrary }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }

        fn is_special(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_special }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }

        fn is_metric(&self) -> bool {
            match *self {
                {{~ #each atoms }}
                {{~ #if is_metric }}
                Atom::{{ type_name }} => true,
                {{~ /if}}{{ /each }}
                _ => false,
            }
        }
    }

    impl Reducible for Atom {
        fn reduce_value(&self, value: f64) -> f64 {
            self.definition().reduce_value(value)
        }

        fn calculate_magnitude(&self, value: f64) -> f64 {
            if self.is_special() {
                self.definition().calculate_magnitude(value)
            } else {
                1.0
            }
        }
    }

    impl DefaultCompatibility for Atom {}

    impl Composable for Atom {
        fn composition(self) -> Composition {
            match self {
                Atom::Candela => Composition::new(Dimension::LuminousIntensity, 1),
                Atom::Coulomb => Composition::new(Dimension::ElectricCharge, 1),
                Atom::Gram => Composition::new(Dimension::Mass, 1),
                Atom::Kelvin => Composition::new(Dimension::Temperature, 1),
                Atom::Meter => Composition::new(Dimension::Length, 1),
                Atom::Radian => Composition::new(Dimension::PlaneAngle, 1),
                Atom::Second => Composition::new(Dimension::Time, 1),
                _ => self.definition().terms().composition(),
            }
        }
    }

    impl PartialEq for Atom {
        fn eq(&self, other: &Self) -> bool {
            if !self.is_compatible_with(*other) {
                return false;
            }

            self.scalar() == other.scalar()
        }
    }

    impl fmt::Display for Atom {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.primary_code())
        }
    }
}
