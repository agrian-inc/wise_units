//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated at compile time.
//-----------------------------------------------------------------------------

pub(super) mod mapper {
    use crate::parser::{Atom, Error, Prefix};
    use crate::parser::symbols::Symbol;
    // use crate::parser::symbols::symbol_parser::Rule;
    use crate::parser::terms::term_parser::Rule;
    use pest::iterators::Pair;

    pub(in super::super) fn map(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
        fn visit_pairs(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
            let symbol = match pair.as_rule() {
                Rule::symbol => visit_symbol(pair)?,
                _ => {
                    let error = Error::UnableToParse {
                        expression: pair.as_str().to_string(),
                    };

                    return Err(error);
                }
            };

            Ok(symbol)
        }

        let symbol = visit_pairs(pair)?;

        Ok(symbol)
    }

    fn visit_symbol(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
        let mut prefix: Option<Prefix> = None;
        let mut atom: Option<Atom> = None;

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::pri_prefix | Rule::sec_prefix => {
                    let next = inner_pair
                        .into_inner()
                        .next()
                        .expect("Unable to get next prefix");
                    prefix = Some(visit_prefix(&next)?);

                }
                Rule::pri_atom | Rule::sec_atom => {
                    let next = inner_pair
                        .into_inner()
                        .next()
                        .expect("Unable to get next atom");

                    atom = Some(visit_atom(&next)?);
                }
                _ => {
                    let error = Error::UnableToParse {
                        expression: inner_pair.as_str().to_string(),
                    };

                    return Err(error);
                }
            }
        }

        Ok(Symbol { prefix, atom })
    }

    fn visit_atom(pair: &Pair<'_, Rule>) -> Result<Atom, Error> {
        let atom = match pair.as_rule() {
            {{~ #each mappings }}
            Rule::{{ primary_rule_name }} {{~ #if secondary_rule_name }} | Rule::{{ secondary_rule_name }} {{~ /if }} => Atom::{{ @key }},{{ /each }}
            _ => return Err(Error::UnknownUnitString(pair.as_str().to_string())),
        };

        Ok(atom)
    }

    fn visit_prefix(pair: &Pair<'_, Rule>) -> Result<Prefix, Error> {
        let prefix = match pair.as_str() {
            "a" | "A" => Prefix::Atto,
            "c" | "C" => Prefix::Centi,
            "d" | "D" => Prefix::Deci,
            "da" | "DA" => Prefix::Deka,
            "E" | "EX" => Prefix::Exa,
            "f" | "F" => Prefix::Femto,
            "Gi" | "GIB" => Prefix::Gibi,
            "G" | "GA" => Prefix::Giga,
            "h" | "H" => Prefix::Hecto,
            "k" | "K" => Prefix::Kilo,
            "Mi" | "MIB" => Prefix::Mebi,
            "M" | "MA" => Prefix::Mega,
            "u" | "U" => Prefix::Micro,
            "m" | "M" => Prefix::Milli,
            "n" | "N" => Prefix::Nano,
            "P" | "PT" => Prefix::Peta,
            "Ti" | "TIB" => Prefix::Tebi,
            "T" | "TR" => Prefix::Tera,
            "y" | "YO" => Prefix::Yocto,
            "Y" | "YA" => Prefix::Yotta,
            "z" | "ZO" => Prefix::Zepto,
            "Z" | "ZA" => Prefix::Zetta,
            _ => return Err(Error::UnknownUnitString(pair.as_str().to_string())),
        };

        Ok(prefix)
    }
}
