//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated at compile time.
//-----------------------------------------------------------------------------

#[allow(clippy::too_many_lines)]
pub(super) mod mapper {
    use crate::parser::{Atom, Error, Prefix};
    use crate::parser::symbols::Symbol;
    use crate::parser::symbols::symbol_parser::Rule;
    use pest::iterators::Pair;

    pub(in super::super) fn map(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
        fn visit_pairs(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
            let symbol = if let Rule::symbol = pair.as_rule() {
                visit_symbol(pair)?
            } else {
                let error = Error::UnableToParse {
                    expression: pair.as_str().to_string(),
                };

                return Err(error);
            };

            Ok(symbol)
        }

        let symbol = visit_pairs(pair)?;

        Ok(symbol)
    }

    fn visit_symbol(pair: Pair<'_, Rule>) -> Result<Symbol, Error> {
        let mut prefix: Option<Prefix> = None;
        let mut atom: Option<Atom> = None;

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::pri_prefix | Rule::sec_prefix => {
                    let next = inner_pair
                        .into_inner()
                        .next()
                        .expect("Unable to get next prefix");
                    prefix = Some(visit_prefix(&next)?);

                }
                Rule::pri_atom | Rule::sec_atom => {
                    let next = inner_pair
                        .into_inner()
                        .next()
                        .expect("Unable to get next atom");

                    atom = Some(visit_atom(&next)?);
                }
                _ => {
                    let error = Error::UnableToParse {
                        expression: inner_pair.as_str().to_string(),
                    };

                    return Err(error);
                }
            }
        }

        Ok(Symbol { prefix, atom })
    }

    fn visit_atom(pair: &Pair<'_, Rule>) -> Result<Atom, Error> {
        let atom = match pair.as_rule() {
            {{~ #each mappings }}
            Rule::{{ primary_rule_name }} {{~ #if secondary_rule_name }} | Rule::{{ secondary_rule_name }} {{~ /if }} => Atom::{{ @key }},{{ /each }}
            _ => return Err(Error::UnknownUnitString(pair.as_str().to_string())),
        };

        Ok(atom)
    }

    fn visit_prefix(pair: &Pair<'_, Rule>) -> Result<Prefix, Error> {
        let prefix = match pair.as_rule() {
            Rule::pri_atto | Rule::sec_atto => Prefix::Atto,
            Rule::pri_centi | Rule::sec_centi => Prefix::Centi,
            Rule::pri_deci | Rule::sec_deci => Prefix::Deci,
            Rule::pri_deka | Rule::sec_deka => Prefix::Deka,
            Rule::pri_exa | Rule::sec_exa => Prefix::Exa,
            Rule::pri_femto | Rule::sec_femto => Prefix::Femto,
            Rule::pri_gibi | Rule::sec_gibi => Prefix::Gibi,
            Rule::pri_giga | Rule::sec_giga => Prefix::Giga,
            Rule::pri_hecto | Rule::sec_hecto => Prefix::Hecto,
            Rule::pri_kilo | Rule::sec_kilo => Prefix::Kilo,
            Rule::pri_mebi | Rule::sec_mebi => Prefix::Mebi,
            Rule::pri_mega | Rule::sec_mega => Prefix::Mega,
            Rule::pri_micro | Rule::sec_micro => Prefix::Micro,
            Rule::pri_milli | Rule::sec_milli => Prefix::Milli,
            Rule::pri_nano | Rule::sec_nano => Prefix::Nano,
            Rule::pri_peta | Rule::sec_peta => Prefix::Peta,
            Rule::pri_tebi | Rule::sec_tebi => Prefix::Tebi,
            Rule::pri_tera | Rule::sec_tera => Prefix::Tera,
            Rule::pri_yocto | Rule::sec_yocto => Prefix::Yocto,
            Rule::pri_yotta | Rule::sec_yotta => Prefix::Yotta,
            Rule::pri_zepto | Rule::sec_zepto => Prefix::Zepto,
            Rule::pri_zetta | Rule::sec_zetta => Prefix::Zetta,
            _ => return Err(Error::UnknownUnitString(pair.as_str().to_string())),
        };

        Ok(prefix)
    }
}
